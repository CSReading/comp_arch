## 6.3
>図6‒1、6‒2 を参考にして、次の命令がメモリに格納されているとき、個々のビット
がどうなるかを示しなさい。

```load r7, 43(r15)```

| 演算  | reg A | 未使用 | dst reg | offset           | 
| :---: | :---: | :----: | :-----: | :--------------: | 
| 00010 | 01111 | 00000  | 00111   | 0000000000101011 | 


## 6.8
>データパス図（たとえば図6‒8）では、多くの詳細が隠されています。もしサンプル
を変更して、どの命令も64bit 長にしたら、この図にどれほどの変更が必要になりま
すか?

32bit長の命令の際, 次の命令に進むためには命令ポイントを4byte (32bit) インクリメントする
必要があった. 64bitは8byteであるから, adderで加算する定数は8となる.
あとは, 32bit pgm. ctr. と32bit adderを64bitのものに変更すればよい.

その他の図中のコンポーネントは, 内部的には64bit長に合わせた命令セットの変更などが含まれているはずだが,
図に反映されるような変更ではない.

## 6.13
>図6‒8 のコンピュータシステムを、相対分岐命令を含むように再設計しましょう。
「オフセット」フィールドに符号付きの値が含まれることにします。その値を現在のプ
ログラムカウンタに加算してプログラムカウンタの次の値を作るようにしましょう。

本文p116の絶対分岐命令`jump`を参考にする.

![画像](6_13.png)

相対分岐命令`br`がメモリからフェッチされ, デコードされたら, 
コントローラがマルチプレクサM2, M4の設定により, プログラムカウンタの値と
命令の「オフセット」フィールドを渡して, ALUに加算の実行を指示する.
ALUは, オフセットをプログラムカウンタの内容に加算する.
その結果をアドレスとして使うため, コントローラはALUからの出力を渡し,
データメモリからの出力は無視するようにマルチプレクサM3を設定する.
最後にコントローラは, マルチプレクサM1を設定して, ALUからの値をプログラムカウンタに渡す.
これによって, ALUが出した結果が, 32bitプログラムカウンタの入力になる.
プログラムカウンタが,その値を受け取って格納すると, 命令は完了する.
プログラムカウンタは, 次の命令をフェッチすべきメモリアドレスを常に指定する.
したがって, 次に命令を実行するときは, 前の命令で計算したアドレスから命令が取り出される.
つまりプログラムは新しい場所にジャンプする.